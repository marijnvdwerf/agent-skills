---
name: n64-decomp
description: |
  N64 game decompilation workflow assistant. Use when helping with Nintendo 64 reverse engineering tasks including: (1) Setting up new decomp projects with splat64 and uv, (2) Creating build systems with ninja, (3) Identifying libultra versions and symbols, (4) Finding compiler versions via decomp.me, (5) Converting assembly to C code. Triggers on mentions of N64/Nintendo 64 decompilation, splat, decomp.me, libultra, or MIPS assembly matching.
---

# N64 Decompilation

## Project Setup

First, ask user if they want to initialize a git repository for this project.

Initialize with uv (not pip) for better version locking:

```bash
uv init --bare
uv add "splat64[mips]"
```

Copy ROM to project folder as `baserom.<extension>` (keep original extension):

```bash
cp "/path/to/Game Name.n64" baserom.n64
```

Generate config from ROM (splat handles byteswapping internally):

```bash
uv run -m splat create_config baserom.n64
```

After config generation, splat creates a byteswapped `baserom.z64`. From this point on, always use `baserom.z64` (the build system expects z64 format).

After config is generated, enable undefined symbol paths in the yaml (uncomment these lines):

```yaml
undefined_funcs_auto_path: undefined_funcs_auto.txt
undefined_syms_auto_path: undefined_syms_auto.txt
```

Do NOT enable `hardware_regs` or `libultra_symbols` - they cause symbol mismatches and are unnecessary work.

Split the ROM:

```bash
uv run -m splat split <game>.yaml
```

Splat generates `include/macro.inc` automatically - do not create it manually.

Add to `.gitignore` (avoid copyright issues):
- `baserom.z64` (or whatever input ROM name)
- All generated folders (`asm/`, `bin/`, `assets/`, etc.)

IMPORTANT: The `asm/` folder is generated by splat and NOT checked in. Never edit asm files directly to fix build issues - those changes won't persist. Instead, fix issues in the YAML config or symbol files.

Splat suggests file splits in output - these are "highly likely" object boundaries detected via zero-padding between functions aligned at 0x10. Add these to the yaml LATER, after basic build works.

Note on splits: Splat detects splits when a function's last instruction is at offset like 0x1C and the next function starts at 0x20 (aligned). If a function ends at 0x1C and the next starts at 0x20 without padding, splat cannot detect the boundary - but one may still exist.

### Splat YAML Subsegment Format

Subsegments use shorthand: `[offset, type]` or `[offset, type, name]`

```yaml
subsegments:
  - [0x1050, asm]                    # name defaults to "1050" (hex offset)
  - [0xA0CD0, asm, libultra/A0CD0]   # explicit name, creates libultra/ folder
```

To rename a file, add the third element. Names with slashes become folders.

## Build System

CRITICAL: Use [references/configure-simple.py](references/configure-simple.py) for initial setup. It handles assembly-only builds. Do NOT use the complex Pokemon Snap example yet - that's for later when adding C compilation.

After creating configure.py, make it executable: `chmod +x configure.py`

Goal: get a matching ROM building. At this stage, compiler doesn't matter since all files are assembly objects.

### BSS Mismatch Issues

NEVER edit asm files to fix address mismatches - they are regenerated by splat and changes are lost.

If entrypoint references `main_BSS_START` with wrong value, calculate `bss_size` from the entry asm file (usually `asm/1000.s` - splat names files by ROM offset, not `entry.s`):

```asm
lui  $t0, 0x800e        # BSS_START high = 0x800e
lui  $t1, (0x7DAC0 >> 16)  # BSS_SIZE high
addiu $t0, $t0, 0x2e00  # BSS_START low = 0x2e00 â†’ BSS_START = 0x800e2e00
ori  $t1, $t1, (0x7DAC0 & 0xFFFF)  # BSS_SIZE = 0x7DAC0
```

Add `bss_size` to the main segment and a `.bss` subsegment in YAML:

```yaml
- name: main
  type: code
  start: 0x1050
  vram: 0x80001050
  bss_size: 0x7DAC0
  subsegments:
    - [0x1050, asm]
    - { start: 0xB1BD0, type: .bss, vram: 0x800E2E00 }
```

The `.bss` vram should match BSS_START calculated from entrypoint. Then re-run `python configure.py --clean` and rebuild.

Once building succeeds:
1. Add the suggested splits from splat output to the yaml
2. Rebuild and verify still matches
3. Checkpoint: verify build matches, then commit
4. Proceed to libultra identification

Checkpoints are good points to verify your build still matches, and commit your work. Do not wait for user input at checkpoints.

## Identifying libultra

### Find Version

Check `asm/header.s` for revision field:

```asm
.word 0x00001448       /* Revision */
```

The byte (0x48 = 'H') encodes libultra SDK version as ASCII (E=2.0E, F=2.0F, ... L=2.0L). See https://n64brew.dev/wiki/Libultra for version history.

### Setup

```bash
git clone https://github.com/decompals/ultralib
rm -rf ultralib/.git
uv add git+https://github.com/matt-kempster/m2c
```

Download ultralib into the project and commit it (remove .git, not a submodule). Do NOT add ultralib to .gitignore.

After adding ultralib, update configure.py to include its headers in compilation:
```python
INCLUDES = "-I include -I ultralib/include -I ultralib/include/PR"
```

### Get n64sym Hints First

BEFORE doing any analysis, ask user to run n64sym and paste the output: https://shygoo.github.io/n64sym/web/

Wait for user to provide n64sym output. Use it to estimate:
- Where libultra might start (look for first os* function address)
- Where libultra might end
- Which functions might be present

WARNING: n64sym is UNRELIABLE - pattern-matches against known binaries. NEVER add symbols directly. Use ONLY as hints for where to look.

### Find libultra Boundaries

NOTE: Do not read raw asm files - they are large and token-inefficient. Always use m2c first:
```bash
uv run m2c asm/<file>.s
```

1. **Find start of libultra**: Based on n64sym hints, check candidate files with m2c
   - Compare m2c output against ultralib source
   - When matched, rename in yaml: `[0xA0CD0, asm, libultra/A0CD0]`

2. **Find end of libultra**: Same process for last libultra function

3. **Rename ALL files** in the libultra range in the yaml subsegments

4. **Rebuild** to verify still matches

Libultra is typically one continuous block of modules.

### Identify Called Functions

Find ALL function calls INTO the libultra VRAM range:

```bash
# Find calls to libultra address range (adjust range for your ROM)
rg "jal.*0x800[a-f]" asm/
```

Continue until you have identified ALL unique libultra functions called from game code. These are the priority - game code needs to know their signatures.

### Add Symbols Module-by-Module

For each called function:
1. Run m2c on the file containing that address
2. Match m2c output to ultralib source
3. Add function symbol to symbol_addrs.txt (text symbols more important than data)
4. Rebuild and verify

For symbol syntax, see https://github.com/ethteck/splat/wiki/Adding-Symbols

Do not stop until all calls into libultra are identified. Checkpoint: verify build matches, commit, then proceed to compiler identification.

## Identifying Compiler Version

The compiler type is in the yaml under `options.compiler` (detected by splat).

### Using decomp.me

1. Find a small, linear function outside libultra
2. Run through m2c: `uv run m2c asm/<file>.s`
3. Guide user to https://decomp.me/new with:
   - Target assembly (from the .s file)
   - m2c output as starting point
   - Function signatures for called functions
   - Typedefs (s32, u32, etc.)
4. User tries presets until one matches

Prefer functions with simple control flow - fewer branches = fewer ways to write equivalent C.

### IDO Specifics

If compiler is IDO (most common), see the `n64-decomp-ido` skill for setting up asm-processor and build integration.

For compiler downloads, see https://github.com/decompme/compilers/blob/main/values.yaml

## Converting to C

Change file type from `asm` to `c` in splatfile. This generates:
- C file with function stubs
- Separate .s files per function

Can do this earlier for the "identification function" to give user a single target .asm file.
